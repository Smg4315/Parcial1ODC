// In this code we will define an 32-bit ALU starting from code 16-bit ALU

CHIP ALU {
    IN  
        x1[16], y1[16], x2[16], y2[16], // 32-bit inputs
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute (out = x + y) or (out = x & y)?
        no; // negate the out output?
    OUT 
        out[32], // 32-bit output
        zr,      // if (out == 0) equals 1, else 0
        ng;      // if (out < 0)  equals 1, else 0

    PARTS:
    
    // Desarollo de entrada X

    // Desarrollo de X1
    // Mux x1 o entrada igual a 0 (Zx1)
    MUX16(a=x1, b= false, sel=zx, out=x1_z);

    // Negar la entrada 
    NOT16(in=x1_z, out=x1_n); 

    // Implementamos el Nx1 (negar o no la entrada)
    MUX16(a=x1_z, b=x1_n, sel=nx, out=x1_out);

    //Desarollo de x2
    // Mux x2 o entrada igual a 0 (Zx2)
    MUX16(a=x2, b= false, sel=zx, out=x2_z);

    // Negar la entrada 
    NOT16(in=x2_z, out=x2_n); 

    // Implementamos el Nx2 (negar o no la entrada)
    MUX16(a=x2_z, b=x2_n, sel=nx, out=x2_out);

    // Desarollo de entrada Y

    // Desarrollo de Y1
    // Mux y1 o entrada igual a 0 (Zy1)
    MUX16(a=y1, b= false, sel=zy, out=y1_z);

    // Negar la entrada 
    NOT16(in=y1_z, out=y1_n); 

    // Implementamos el Ny1 (negar o no la entrada)
    MUX16(a=y1_z, b=y1_n, sel=ny, out=y1_out);

    //Desarollo de y2
    // Mux y2 o entrada igual a 0 (Zy2)
    MUX16(a=y2, b= false, sel=zy, out=y2_z);

    // Negar la entrada 
    NOT16(in=y2_z, out=y2_n);

    // Implementamos el Ny2 (negar o no la entrada)
    MUX16(a=y2_z, b=y2_n, sel=ny, out=y2_out);

}